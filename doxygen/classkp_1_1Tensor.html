<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kompute: kp::Tensor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kompute
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>kp</b></li><li class="navelem"><a class="el" href="classkp_1_1Tensor.html">Tensor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classkp_1_1Tensor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">kp::Tensor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Tensor_8hpp_source.html">Tensor.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1b2af1c0e8dc0f154e11780e7103beb4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a> { <a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4a4380df4c549f2a42e0f127869f41bd4f">TensorTypes::eDevice</a> = 0, 
<a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4ab288dd012e30ff97c0236b12e3c2c6e5">TensorTypes::eStaging</a> = 1, 
<a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4ae1a7e733531f08074becd467959f0521">TensorTypes::eStorage</a> = 2
 }</td></tr>
<tr class="separator:a1b2af1c0e8dc0f154e11780e7103beb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aee6c5bb44b1c58d67c33c86efdc24acd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#aee6c5bb44b1c58d67c33c86efdc24acd">Tensor</a> ()</td></tr>
<tr class="separator:aee6c5bb44b1c58d67c33c86efdc24acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64277a710229f5407f3975f9164da26a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a64277a710229f5407f3975f9164da26a">Tensor</a> (const std::vector&lt; float &gt; &amp;<a class="el" href="classkp_1_1Tensor.html#a858f9a010a112983244cdf16ea0e5308">data</a>, <a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a> <a class="el" href="classkp_1_1Tensor.html#a59452f1c62fd738536bb0a6cbf8d896b">tensorType</a>=<a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4a4380df4c549f2a42e0f127869f41bd4f">TensorTypes::eDevice</a>)</td></tr>
<tr class="separator:a64277a710229f5407f3975f9164da26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e886e69103a956b994790f320a254e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a38e886e69103a956b994790f320a254e">~Tensor</a> ()</td></tr>
<tr class="separator:a38e886e69103a956b994790f320a254e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb298bd2aea2bd9cea4eb9a741d2de3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#abbb298bd2aea2bd9cea4eb9a741d2de3">init</a> (std::shared_ptr&lt; vk::PhysicalDevice &gt; physicalDevice, std::shared_ptr&lt; vk::Device &gt; device)</td></tr>
<tr class="separator:abbb298bd2aea2bd9cea4eb9a741d2de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfc816a4f040ad43e36534c6fbc69a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#afdfc816a4f040ad43e36534c6fbc69a2">freeMemoryDestroyGPUResources</a> ()</td></tr>
<tr class="separator:afdfc816a4f040ad43e36534c6fbc69a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858f9a010a112983244cdf16ea0e5308"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a858f9a010a112983244cdf16ea0e5308">data</a> ()</td></tr>
<tr class="separator:a858f9a010a112983244cdf16ea0e5308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ff1ca98d5380cc3916e13b20f7a509"><td class="memItemLeft" align="right" valign="top">float &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a64ff1ca98d5380cc3916e13b20f7a509">operator[]</a> (int index)</td></tr>
<tr class="separator:a64ff1ca98d5380cc3916e13b20f7a509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb937df6cc482c1f37c74d8fab0f9a9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a1fb937df6cc482c1f37c74d8fab0f9a9">size</a> ()</td></tr>
<tr class="separator:a1fb937df6cc482c1f37c74d8fab0f9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a95b98a2558fbc80458c22ca9e043c"><td class="memItemLeft" align="right" valign="top">std::array&lt; uint32_t, KP_MAX_DIM_SIZE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a70a95b98a2558fbc80458c22ca9e043c">shape</a> ()</td></tr>
<tr class="separator:a70a95b98a2558fbc80458c22ca9e043c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59452f1c62fd738536bb0a6cbf8d896b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a59452f1c62fd738536bb0a6cbf8d896b">tensorType</a> ()</td></tr>
<tr class="separator:a59452f1c62fd738536bb0a6cbf8d896b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ae7f0b57fd8e57570ab63962a97f36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#af2ae7f0b57fd8e57570ab63962a97f36">isInit</a> ()</td></tr>
<tr class="separator:af2ae7f0b57fd8e57570ab63962a97f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3618a3e5a86cfaad31820f9910525424"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a3618a3e5a86cfaad31820f9910525424">setData</a> (const std::vector&lt; float &gt; &amp;<a class="el" href="classkp_1_1Tensor.html#a858f9a010a112983244cdf16ea0e5308">data</a>)</td></tr>
<tr class="separator:a3618a3e5a86cfaad31820f9910525424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b54d0040e09e918620fcce44651fb24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a1b54d0040e09e918620fcce44651fb24">recordCopyFrom</a> (std::shared_ptr&lt; vk::CommandBuffer &gt; commandBuffer, std::shared_ptr&lt; <a class="el" href="classkp_1_1Tensor.html">Tensor</a> &gt; copyFromTensor, bool createBarrier)</td></tr>
<tr class="separator:a1b54d0040e09e918620fcce44651fb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3c387940770f7d6de891ece13190bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a2b3c387940770f7d6de891ece13190bd">recordBufferMemoryBarrier</a> (std::shared_ptr&lt; vk::CommandBuffer &gt; commandBuffer, vk::AccessFlagBits srcAccessMask, vk::AccessFlagBits dstAccessMask, vk::PipelineStageFlagBits srcStageMask, vk::PipelineStageFlagBits dstStageMask)</td></tr>
<tr class="separator:a2b3c387940770f7d6de891ece13190bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805e6050a935763488116e071c0ce461"><td class="memItemLeft" align="right" valign="top">vk::DescriptorBufferInfo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a805e6050a935763488116e071c0ce461">constructDescriptorBufferInfo</a> ()</td></tr>
<tr class="separator:a805e6050a935763488116e071c0ce461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e16f48058f17d55d313727c9ceaa46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#ae8e16f48058f17d55d313727c9ceaa46">mapDataFromHostMemory</a> ()</td></tr>
<tr class="separator:ae8e16f48058f17d55d313727c9ceaa46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeeb1b7d8ed4681565f17e44c98fb704"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#aeeeb1b7d8ed4681565f17e44c98fb704">mapDataIntoHostMemory</a> ()</td></tr>
<tr class="separator:aeeeb1b7d8ed4681565f17e44c98fb704"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Structured data used in GPU operations.</p>
<p>Tensors are the base building block in Kompute to perform operations across GPUs. Each tensor would have a respective Vulkan memory and buffer, which would be used to store their respective data. The tensors can be used for GPU data storage or transfer. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a1b2af1c0e8dc0f154e11780e7103beb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2af1c0e8dc0f154e11780e7103beb4">&#9670;&nbsp;</a></span>TensorTypes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">kp::Tensor::TensorTypes</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type for tensors created: Device allows memory to be transferred from staging buffers. Staging are host memory visible. Storage are device visible but are not set up to transfer or receive data (only for shader storage). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1b2af1c0e8dc0f154e11780e7103beb4a4380df4c549f2a42e0f127869f41bd4f"></a>eDevice&#160;</td><td class="fielddoc"><p>Type is device memory, source and destination. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1b2af1c0e8dc0f154e11780e7103beb4ab288dd012e30ff97c0236b12e3c2c6e5"></a>eStaging&#160;</td><td class="fielddoc"><p>Type is host memory, source and destination. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1b2af1c0e8dc0f154e11780e7103beb4ae1a7e733531f08074becd467959f0521"></a>eStorage&#160;</td><td class="fielddoc"><p>Type is Device memory (only) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aee6c5bb44b1c58d67c33c86efdc24acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6c5bb44b1c58d67c33c86efdc24acd">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kp::Tensor::Tensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Base constructor, should not be used unless explicitly intended. </p>

</div>
</div>
<a id="a64277a710229f5407f3975f9164da26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64277a710229f5407f3975f9164da26a">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kp::Tensor::Tensor </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a>&#160;</td>
          <td class="paramname"><em>tensorType</em> = <code><a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4a4380df4c549f2a42e0f127869f41bd4f">TensorTypes::eDevice</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor with data provided which would be used to create the respective vulkan buffer and memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Vector of data that will be used by the tensor </td></tr>
    <tr><td class="paramname">tensorType</td><td>Type for the tensor which is of type TensorTypes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38e886e69103a956b994790f320a254e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e886e69103a956b994790f320a254e">&#9670;&nbsp;</a></span>~Tensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kp::Tensor::~Tensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor which is in charge of freeing vulkan resources unless they have been provided externally. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a805e6050a935763488116e071c0ce461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805e6050a935763488116e071c0ce461">&#9670;&nbsp;</a></span>constructDescriptorBufferInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vk::DescriptorBufferInfo kp::Tensor::constructDescriptorBufferInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a vulkan descriptor buffer info which can be used to specify and reference the underlying buffer component of the tensor without exposing it.</p>
<dl class="section return"><dt>Returns</dt><dd>Descriptor buffer info with own buffer </dd></dl>

</div>
</div>
<a id="a858f9a010a112983244cdf16ea0e5308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858f9a010a112983244cdf16ea0e5308">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt;&amp; kp::Tensor::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the vector of data currently contained by the <a class="el" href="classkp_1_1Tensor.html">Tensor</a>. It is important to ensure that there is no out-of-sync data with the GPU memory.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to vector of elements representing the data in the tensor. </dd></dl>

</div>
</div>
<a id="afdfc816a4f040ad43e36534c6fbc69a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfc816a4f040ad43e36534c6fbc69a2">&#9670;&nbsp;</a></span>freeMemoryDestroyGPUResources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::freeMemoryDestroyGPUResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys and frees the GPU resources which include the buffer and memory. </p>

</div>
</div>
<a id="abbb298bd2aea2bd9cea4eb9a741d2de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb298bd2aea2bd9cea4eb9a741d2de3">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::init </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; vk::PhysicalDevice &gt;&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; vk::Device &gt;&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialiser which calls the initialisation for all the respective tensors as well as creates the respective staging tensors. The staging tensors would only be created for the tensors of type TensorType::eDevice as otherwise there is no need to copy from host memory. </p>

</div>
</div>
<a id="af2ae7f0b57fd8e57570ab63962a97f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ae7f0b57fd8e57570ab63962a97f36">&#9670;&nbsp;</a></span>isInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kp::Tensor::isInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the tensor initialisation function has been carried out successful, which would mean that the buffer and memory will have been provisioned. </p>

</div>
</div>
<a id="ae8e16f48058f17d55d313727c9ceaa46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e16f48058f17d55d313727c9ceaa46">&#9670;&nbsp;</a></span>mapDataFromHostMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::mapDataFromHostMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maps data from the Host Visible GPU memory into the data vector. It requires the <a class="el" href="classkp_1_1Tensor.html">Tensor</a> to be of staging type for it to work. </p>

</div>
</div>
<a id="aeeeb1b7d8ed4681565f17e44c98fb704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeeb1b7d8ed4681565f17e44c98fb704">&#9670;&nbsp;</a></span>mapDataIntoHostMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::mapDataIntoHostMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maps data from the data vector into the Host Visible GPU memory. It requires the tensor to be of staging type for it to work. </p>

</div>
</div>
<a id="a64ff1ca98d5380cc3916e13b20f7a509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ff1ca98d5380cc3916e13b20f7a509">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float&amp; kp::Tensor::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overrides the subscript operator to expose the underlying data's subscript operator which in this case would be its underlying vector's.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index where the element will be returned from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the element in the position requested. </dd></dl>

</div>
</div>
<a id="a2b3c387940770f7d6de891ece13190bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3c387940770f7d6de891ece13190bd">&#9670;&nbsp;</a></span>recordBufferMemoryBarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::recordBufferMemoryBarrier </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; vk::CommandBuffer &gt;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::AccessFlagBits&#160;</td>
          <td class="paramname"><em>srcAccessMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::AccessFlagBits&#160;</td>
          <td class="paramname"><em>dstAccessMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::PipelineStageFlagBits&#160;</td>
          <td class="paramname"><em>srcStageMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::PipelineStageFlagBits&#160;</td>
          <td class="paramname"><em>dstStageMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records the buffer memory barrier into the command buffer which ensures that relevant data transfers are carried out correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>Vulkan Command Buffer to record the commands into </td></tr>
    <tr><td class="paramname">srcAccessMask</td><td>Access flags for source access mask </td></tr>
    <tr><td class="paramname">dstAccessMask</td><td>Access flags for destination access mask </td></tr>
    <tr><td class="paramname">scrStageMask</td><td>Pipeline stage flags for source stage mask </td></tr>
    <tr><td class="paramname">dstStageMask</td><td>Pipeline stage flags for destination stage mask </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b54d0040e09e918620fcce44651fb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b54d0040e09e918620fcce44651fb24">&#9670;&nbsp;</a></span>recordCopyFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::recordCopyFrom </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; vk::CommandBuffer &gt;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classkp_1_1Tensor.html">Tensor</a> &gt;&#160;</td>
          <td class="paramname"><em>copyFromTensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createBarrier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records a copy from the memory of the tensor provided to the current thensor. This is intended to pass memory into a processing, to perform a staging buffer transfer, or to gather output (between others).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>Vulkan Command Buffer to record the commands into </td></tr>
    <tr><td class="paramname">copyFromTensor</td><td><a class="el" href="classkp_1_1Tensor.html">Tensor</a> to copy the data from </td></tr>
    <tr><td class="paramname">createBarrier</td><td>Whether to create a barrier that ensures the data is copied before further operations. Default is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3618a3e5a86cfaad31820f9910525424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3618a3e5a86cfaad31820f9910525424">&#9670;&nbsp;</a></span>setData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::setData </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets / resets the vector data of the tensor. This function does not perform any copies into GPU memory and is only performed on the host. </p>

</div>
</div>
<a id="a70a95b98a2558fbc80458c22ca9e043c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a95b98a2558fbc80458c22ca9e043c">&#9670;&nbsp;</a></span>shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;uint32_t, KP_MAX_DIM_SIZE&gt; kp::Tensor::shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the shape of the tensor, which includes the number of dimensions and the size per dimension.</p>
<dl class="section return"><dt>Returns</dt><dd>Array containing the sizes for each dimension. Zero means respective dimension is not active. </dd></dl>

</div>
</div>
<a id="a1fb937df6cc482c1f37c74d8fab0f9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb937df6cc482c1f37c74d8fab0f9a9">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t kp::Tensor::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size/magnitude of the <a class="el" href="classkp_1_1Tensor.html">Tensor</a>, which will be the total number of elements across all dimensions</p>
<dl class="section return"><dt>Returns</dt><dd>Unsigned integer representing the total number of elements </dd></dl>

</div>
</div>
<a id="a59452f1c62fd738536bb0a6cbf8d896b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59452f1c62fd738536bb0a6cbf8d896b">&#9670;&nbsp;</a></span>tensorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a> kp::Tensor::tensorType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the tensor type of the <a class="el" href="classkp_1_1Tensor.html">Tensor</a></p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classkp_1_1Tensor.html">Tensor</a> type of tensor </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/axsau/Programming/vulkan/vulkan-compute/src/include/kompute/<a class="el" href="Tensor_8hpp_source.html">Tensor.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
